---
title: "Gary_ggs2121"
author: "Gary Sztajnman"
date: "May 13, 2016"
output: html_document
---

### A Social network analysis
In the previous part of this project, we analyzed the main words in the speeches, the ratings, the sentiment of the next and other metrics.

Here we want to compare the US presidents using social network analysis.
We are going to connect a president to another one based on the similarity of their speeches.
To be coherent with the rest of the analysis, we will continue extracting top 30 words for each speach and computing cosine similarity.

First, we create a adjacency matrix between every pair of president.
If president i has a very similar speech than president j, then we note president_matrix[i,j] = 1 else 0
```{r, echo=FALSE, warning=FALSE, message=FALSE}
load('data/top10word_matrix.Rda')
require('igraph')
require('tm')
require('proxy')
require('dplyr')
require("ggplot2")

topwords <- data.frame(top10word_matrix)


president_matrix <- matrix(data=0, nrow=41, ncol=41)

for (i in 1:dim(topwords)[1]){ 
  for (j in 1:dim(topwords)[1]){
    president_matrix[i,j] = dist(rbind(topwords[i,],topwords[j,]), method = "cosine")
  }
}

president_ties <- matrix(data=0, nrow=41, ncol=41)
for (i in 1:dim(topwords)[1]){ 
  for (j in 1:dim(topwords)[1]){
    president_ties[i,j] = president_matrix[i,j] < median(president_matrix)
  }
}

rownames(president_ties) <- rownames(topwords)
colnames(president_ties) <- rownames(topwords)
```


To go further in the analysis, we want to add concrete attribute about each president such as their political parties, the number of year in office or their popularity
```{r, echo=FALSE, warning=FALSE, message=FALSE}
president <- read.csv("data/President_Info3.csv", header = TRUE)
president <- president[,c(3,7,8,16,17,18,19,20)]
president$name <- as.character(president$name)

president_unique <- president[1,]
for (i in 2:dim(president)[1]) { 
  if (president[i,1] != president[i-1,1]) {
    president_unique <- rbind(president_unique,president[i,])
  }
}
rownames(president_unique) <- rownames(topwords)

# Update missing value and cleaning data
president_unique[which(president_unique$name == 'Barack Obama'),2] = 8
president_unique$elec2 <- as.numeric(as.character(president_unique$X..electoral))
president_unique$elec2[which(is.na(president_unique$elec2))] = mean(president_unique$elec2, na.rm=TRUE)
president_unique$pop2 <- as.numeric(as.character(president_unique$X..popular))
president_unique$pop2[which(is.na(president_unique$pop2))] = mean(president_unique$pop2, na.rm=TRUE)
president_unique$popularity <- rowMeans(president_unique[,c(9,10)])
president_unique$Years.in.office <- as.numeric(as.character(president_unique$Years.in.office))
president_unique$Political.Party <- as.factor(president_unique$Political.Party)


## We create the graph and merge it with its attributes.
president_graph <- graph.adjacency(president_ties,mode="undirected",weighted=NULL, diag = FALSE)
vertex_attr(president_graph, index=president_unique$name) <- president_unique

## Adding Social Networks measure
president_unique <- merge(president_unique,  
                           data.frame(  # With a new data.frame
                             name=V(president_graph)$name,  # Where the ID is the Name of each vertex
                             degree= degree(president_graph), # and the degee is its degree
                             btwn= betweenness(president_graph, directed = F),
                             close = closeness(president_graph, mode = c("all"))
                           ),
                           by='name')

```

Now that we have the graph and the attribute, we will start by visualizing the graph and ploting the popularity (size of the node) and their political party (red, blue and other in grey).

```{r, fig.width=10, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

## Plot undecorated first.
par(mfrow=c(1,1))
oldMargins<-par("mar")
par(mar=c(1,1,1,1))

## Set up plot design
set.seed(12)
l <- layout.fruchterman.reingold(president_graph)
l <- layout.norm(l, ymin=-1, ymax=1, xmin=-1, xmax=1)


## Size node by sale. Reduce size of text
V(president_graph)$size <- (V(president_graph)$popularity*0.04)^2
V(president_graph)$label.cex <- 0.5


## Differentiate number of followers by color.
V(president_graph)$color <- "gray50"
V(president_graph)[V(president_graph)$Political.Party == "Republican"]$color <- "blue"
V(president_graph)[V(president_graph)$Political.Party == "Democrat"]$color <- "red"



plot(president_graph, layout=l, edge.arrow.size=.3, edge.curved=.1, rescale=F, edge.width = 0.5)

```

From this graph, we notice that speeches don't cluster by political parties. This is not a big surprise because we have analyzed before that republican and democrat word cloud are very similar.


To analyze the relation between the popularity and the structure of the nodes, we will compare degree of the node and popularity.
The assumption is that presidents are insipired when writting their speeches by previous popular president.
```{r, echo=FALSE, warning=FALSE, message=FALSE}
ggplot(president_unique, aes(x = degree, y = popularity)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red")
```

Here we see that there is no correlation between popularity and the degree of the node so it's not because you are a popular president that other president will copy you.

However, we notice 2 very clean groups in this graph.
To confirm the existence of this two groups we are going to use the Girvan-Newman algorithm which is a hierarchical method used to detect communities in complex systems. We will also had the use shapes to compare speeches before the 1930's and after

```{r, fig.width=10, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

## Differentiate year by share.
## Differentiate number of business unit by shape
V(president_graph)$shape <- "circle"
V(president_graph)[V(president_graph)$year_y > 1930]$shape <- "square"

## run Girvan-Newman partitioning
fgn = edge.betweenness.community (president_graph, directed = F, 
                                  edge.betweenness = TRUE, merges = TRUE,
                                  bridges = TRUE, modularity = TRUE, 
                                  membership = TRUE) 

plot(fgn, president_graph, layout=l, edge.arrow.size=.3, edge.curved=.1, rescale=F, edge.width = 0.3) #plot G-N partitioning



```

As seen before in this analysis, we observe a very clear separation between the vocabulary of president before 1930's and after. The president Calvin Coolidge that was in office in the 1920's is making the transition


In connected graphs there is a natural distance metric between all pairs of nodes, defined by the length of their shortest paths. The farness of a node x is defined as the sum of its distances from all other nodes, and its closeness is the inverse of the farness.
Thus, the more central a node is the lower its total distance from all other nodes.

We want to use this centrality measure to also compute an interesting relation which is the correlation that exist between closeness and year.

```{r, echo=FALSE, warning=FALSE, message=FALSE}


ggplot(president_unique, aes(x = year_y, y = close)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red")

```

It's interesting to see that the oldest the speech the more central it is in the graph. The newest speeches are the furthest.
The insight: we undestand that new speeches tend to be more original and they try to be different from the previous speech to be creative, you are forced to use new words and to update the vocabulary in order to distinguish from other presidents.

